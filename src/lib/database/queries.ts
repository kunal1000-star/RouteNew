// ============================================================================\n// AI DATABASE QUERY UTILITIES - Basic Implementation\n// ============================================================================\n\nimport { supabase } from '../supabase';\n\n// Basic error classes\nexport class DatabaseError extends Error {\n  constructor(message: string, public code?: string, public details?: any) {\n    super(message);\n    this.name = 'DatabaseError';\n  }\n}\n\nexport class VectorSearchError extends DatabaseError {\n  constructor(message: string, details?: any) {\n    super(message, 'VECTOR_SEARCH_ERROR', details);\n    this.name = 'VectorSearchError';\n  }\n}\n\nexport class SecurityError extends DatabaseError {\n  constructor(message: string, details?: any) {\n    super(message, 'SECURITY_ERROR', details);\n    this.name = 'SecurityError';\n  }\n}\n\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n// Chat conversation operations\nexport class ChatQueries {\n  static async createConversation(userId: string, title: string, chatType: 'general' | 'study_assistant' = 'general') {\n    if (!UUID_REGEX.test(userId)) {\n      throw new DatabaseError('Invalid userId: must be UUID', 'INVALID_INPUT');\n    }\n    try {\n      const { data, error } = await supabase\n        .from('chat_conversations')\n        .insert({\n          user_id: userId,\n          title,\n          chat_type: chatType\n        })\n        .select()\n        .single();\n\n      if (error) throw new DatabaseError(`Failed to create conversation: ${error.message}`, error.code, error);\n      return data;\n    } catch (error) {\n      if (error instanceof DatabaseError) throw error;\n      throw new DatabaseError('Failed to create conversation', 'UNKNOWN_ERROR', error);\n    }\n  }\n\n  static async getUserConversations(userId: string, options: { limit?: number; includeArchived?: boolean } = {}) {\n    try {\n      let query = supabase\n        .from('chat_conversations')\n        .select('*')\n        .eq('user_id', userId)\n        .order('updated_at', { ascending: false });\n\n      if (!options.includeArchived) {\n        query = query.eq('is_archived', false);\n      }\n\n      if (options.limit) {\n        query = query.limit(options.limit);\n      }\n\n      const { data, error } = await query;\n      if (error) throw new DatabaseError(`Failed to fetch conversations: ${error.message}`, error.code, error);\n      return data || [];\n    } catch (error) {\n      if (error instanceof DatabaseError) throw error;\n      throw new DatabaseError('Failed to fetch conversations', 'UNKNOWN_ERROR', error);\n    }\n  }\n\n  static async addMessage(conversationId: string, role: 'user' | 'assistant', content: string, metadata: any = {}) {\n    try {\n      const { data, error } = await supabase\n        .from('chat_messages')\n        .insert({\n          conversation_id: conversationId,\n          role,\n          content,\n          model_used: metadata.model_used,\n          provider_used: metadata.provider_used,\n          tokens_used: metadata.tokens_used || 0,\n          latency_ms: metadata.latency_ms,\n          context_included: metadata.context_included || false\n        })\n        .select()\n        .single();\n\n      if (error) throw new DatabaseError(`Failed to add message: ${error.message}`, error.code, error);\n      return data;\n    } catch (error) {\n      if (error instanceof DatabaseError) throw error;\n      throw new DatabaseError('Failed to add message', 'UNKNOWN_ERROR', error);\n    }\n  }\n}\n\n// Memory and vector search operations\nexport class MemoryQueries {\n  static async addMemory(userId: string, content: string, embedding: number[], importanceScore: number, options: any = {}) {\n    try {\n      if (embedding.length !== 1536) {\n        throw new VectorSearchError(`Invalid embedding dimension: expected 1536, got ${embedding.length}`);\n      }\n\n      const { data, error } = await supabase\n        .from('study_chat_memory')\n        .insert({\n          user_id: userId,\n          content,\n          embedding,\n          importance_score: importanceScore,\n          tags: options.tags,\n          source_conversation_id: options.sourceConversationId\n        })\n        .select()\n        .single();\n\n      if (error) throw new DatabaseError(`Failed to add memory: ${error.message}`, error.code, error);\n      return data;\n    } catch (error) {\n      if (error instanceof DatabaseError || error instanceof VectorSearchError) throw error;\n      throw new DatabaseError('Failed to add memory', 'UNKNOWN_ERROR', error);\n    }\n  }\n\n  static async findSimilarMemories(userId: string, embedding: number[], options: any = {}) {\n    try {\n      if (embedding.length !== 1536) {\n        throw new VectorSearchError(`Invalid embedding dimension: expected 1536, got ${embedding.length}`);\n      }\n\n      const { data, error } = await supabase.rpc('find_similar_memories', {\n        p_user_id: userId,\n        p_embedding: embedding,\n        p_limit: options.limit || 5,\n        p_min_similarity: options.min_similarity || 0.7\n      });\n\n      if (error) throw new VectorSearchError(`Vector search failed: ${error.message}`, error);\n\n      let results = data || [];\n      \n      if (options.tags && options.tags.length > 0) {\n        results = results.filter((memory: any) => \n          memory.tags && memory.tags.some((tag: string) => options.tags.includes(tag))\n        );\n      }\n\n      if (options.importance_score) {\n        results = results.filter((memory: any) => memory.importance_score >= options.importance_score);\n      }\n\n      return results;\n    } catch (error) {\n      if (error instanceof DatabaseError || error instanceof VectorSearchError) throw error;\n      throw new VectorSearchError('Failed to search memories', 'UNKNOWN_ERROR', error);\n    }\n  }\n}\n\n// Profile operations\nexport class ProfileQueries {\n  static async upsertProfile(userId: string, profileData: any) {\n    try {\n      const { data, error } = await supabase\n        .from('student_ai_profile')\n        .upsert({\n          user_id: userId,\n          ...profileData,\n          last_updated: new Date().toISOString()\n        })\n        .select()\n        .single();\n\n      if (error) throw new DatabaseError(`Failed to upsert profile: ${error.message}`, error.code, error);\n      return data;\n    } catch (error) {\n      if (error instanceof DatabaseError) throw error;\n      throw new DatabaseError('Failed to upsert profile', 'UNKNOWN_ERROR', error);\n    }\n  }\n\n  static async getProfile(userId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('student_ai_profile')\n        .select('*')\n        .eq('user_id', userId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        throw new DatabaseError(`Failed to fetch profile: ${error.message}`, error.code, error);\n      }\n      return data || null;\n    } catch (error) {\n      if (error instanceof DatabaseError) throw error;\n      throw new DatabaseError('Failed to fetch profile', 'UNKNOWN_ERROR', error);\n    }\n  }\n}\n\n// API usage tracking\nexport class APIUsageQueries {\n  static async logUsage(userId: string | null, featureName: string, providerUsed: string, modelUsed: string, metadata: any = {}) {\n    try {\n      const { data, error } = await supabase.rpc('log_api_usage', {\n        p_user_id: userId,\n        p_feature_name: featureName,\n        p_provider_used: providerUsed,\n        p_model_used: modelUsed,\n        p_tokens_input: metadata.tokens_input || 0,\n        p_tokens_output: metadata.tokens_output || 0,\n        p_latency_ms: metadata.latency_ms || 0,\n        p_success: metadata.success !== false,\n        p_error_message: metadata.error_message\n      });\n\n      if (error) throw new DatabaseError(`Failed to log API usage: ${error.message}`, error.code, error);\n      return data;\n    } catch (error) {\n      if (error instanceof DatabaseError) throw error;\n      throw new DatabaseError('Failed to log API usage', 'UNKNOWN_ERROR', error);\n    }\n  }\n}\n\n// System prompts\nexport class PromptQueries {\n  static async getActivePrompts() {\n    try {\n      const { data, error } = await supabase\n        .from('ai_system_prompts')\n        .select('*')\n        .eq('is_active', true)\n        .order('version', { ascending: false });\n\n      if (error) throw new DatabaseError(`Failed to fetch prompts: ${error.message}`, error.code, error);\n      return data || [];\n    } catch (error) {\n      if (error instanceof DatabaseError) throw error;\n      throw new DatabaseError('Failed to fetch prompts', 'UNKNOWN_ERROR', error);\n    }\n  }\n\n  static async getPromptByName(name: string) {\n    try {\n      const { data, error } = await supabase\n        .from('ai_system_prompts')\n        .select('*')\n        .eq('name', name)\n        .eq('is_active', true)\n        .order('version', { ascending: false })\n        .limit(1)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        throw new DatabaseError(`Failed to fetch prompt: ${error.message}`, error.code, error);\n      }\n      return data || null;\n    } catch (error) {\n      if (error instanceof DatabaseError) throw error;\n      throw new DatabaseError('Failed to fetch prompt', 'UNKNOWN_ERROR', error);\n    }\n  }\n}\n\n// Maintenance operations\n\n// ================= Per-user provider keys and limits =================\nimport { encryptSecret, decryptSecret } from '@/lib/utils/crypto';\n\nexport type Provider = 'openrouter' | 'groq' | 'gemini' | 'mistral' | 'cohere' | 'cerebras';\n\nexport async function upsertUserProviderKey(userId: string, provider: Provider, apiKey: string) {\n  const { ciphertext, iv } = encryptSecret(apiKey);\n  const { error } = await supabase\n    .from('user_provider_keys')\n    .upsert({\n      user_id: userId,\n      provider,\n      encrypted_key: ciphertext,\n      iv,\n      updated_at: new Date().toISOString(),\n    }, { onConflict: 'user_id,provider' });\n  if (error) throw new DatabaseError(`Failed to save provider key: ${error.message}`, error.code, error);\n}\n\nexport async function deleteUserProviderKey(userId: string, provider: Provider) {\n  const { error } = await supabase\n    .from('user_provider_keys')\n    .delete()\n    .eq('user_id', userId)\n    .eq('provider', provider);\n  if (error) throw new DatabaseError(`Failed to delete provider key: ${error.message}`, error.code, error);\n}\n\nexport async function getUserProviderKey(userId: string, provider: Provider): Promise<string | null> {\n  const { data, error } = await supabase\n    .from('user_provider_keys')\n    .select('encrypted_key, iv')\n    .eq('user_id', userId)\n    .eq('provider', provider)\n    .single();\n  if (error && error.code !== 'PGRST116') throw new DatabaseError(`Failed to fetch provider key: ${error.message}`, error.code, error);\n  if (!data) return null;\n  const key = decryptSecret(Buffer.from(data.encrypted_key as any), Buffer.from(data.iv as any));\n  return key;\n}\n\nexport async function listUserProviderKeyStatus(userId: string) {\n  const providers: Provider[] = ['openrouter','groq','gemini','mistral','cohere','cerebras'];\n  const { data, error } = await supabase\n    .from('user_provider_keys')\n    .select('provider')\n    .eq('user_id', userId);\n  if (error) throw new DatabaseError(`Failed to list provider keys: ${error.message}`, error.code, error);\n  const set = new Set((data || []).map(d => d.provider as Provider));\n  return providers.map(p => ({ provider: p, hasKey: set.has(p) }));\n}\n\nexport async function upsertUserProviderLimit(userId: string, provider: Provider, maxPerMin: number) {\n  const { error } = await supabase\n    .from('user_provider_limits')\n    .upsert({\n      user_id: userId,\n      provider,\n      max_requests_per_min: maxPerMin,\n      updated_at: new Date().toISOString(),\n    }, { onConflict: 'user_id,provider' });\n  if (error) throw new DatabaseError(`Failed to save provider limit: ${error.message}`, error.code, error);\n}\n\nexport async function getUserProviderLimit(userId: string, provider: Provider): Promise<number | null> {\n  const { data, error } = await supabase\n    .from('user_provider_limits')\n    .select('max_requests_per_min')\n    .eq('user_id', userId)\n    .eq('provider', provider)\n    .single();\n  if (error && error.code !== 'PGRST116') throw new DatabaseError(`Failed to fetch provider limit: ${error.message}`, error.code, error);\n  return data?.max_requests_per_min ?? null;\n}\n\nexport async function listUserProviderLimits(userId: string): Promise<Array<{provider: Provider; max_requests_per_min: number}>> {\n  const providers: Provider[] = ['openrouter','groq','gemini','mistral','cohere','cerebras'];\n  const { data, error } = await supabase\n    .from('user_provider_limits')\n    .select('provider, max_requests_per_min')\n    .eq('user_id', userId);\n  if (error) throw new DatabaseError(`Failed to list provider limits: ${error.message}`, error.code, error);\n  const map = new Map<string, number>();\n  (data || []).forEach(r => map.set(r.provider as string, r.max_requests_per_min as number));\n  return providers.map(p => ({ provider: p, max_requests_per_min: map.get(p) ?? 60 }));\n}\n\nexport class MaintenanceQueries {\n  static async runMaintenanceTasks() {\n    try {\n      const { data, error } = await supabase.rpc('run_maintenance_tasks');\n      if (error) throw new DatabaseError(`Failed to run maintenance tasks: ${error.message}`, error.code, error);\n      return data || [];\n    } catch (error) {\n      if (error instanceof DatabaseError) throw error;\n      throw new DatabaseError('Failed to run maintenance tasks', 'UNKNOWN_ERROR', error);\n    }\n  }\n}\n