-- AI Suggestions Database Migration
-- Creates tables for storing AI-generated study suggestions

-- Table for storing AI suggestions
CREATE TABLE IF NOT EXISTS ai_suggestions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_type TEXT NOT NULL CHECK (suggestion_type IN ('topic', 'weakness', 'insight', 'analysis', 'recommendation')),
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    priority TEXT CHECK (priority IN ('low', 'medium', 'high')) DEFAULT 'medium',
    estimated_impact INTEGER CHECK (estimated_impact BETWEEN 1 AND 10) DEFAULT 5,
    reasoning TEXT,
    actionable_steps TEXT[] DEFAULT '{}',
    related_topics TEXT[] DEFAULT '{}',
    confidence_score DECIMAL(3,2) CHECK (confidence_score BETWEEN 0 AND 1) DEFAULT 0.5,
    metadata JSONB DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    is_applied BOOLEAN DEFAULT false,
    applied_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '6 hours'),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Table for student profiles used for suggestion generation
CREATE TABLE IF NOT EXISTS student_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
    performance_data JSONB NOT NULL DEFAULT '{}',
    historical_data JSONB NOT NULL DEFAULT '{}',
    profile_version INTEGER DEFAULT 1,
    last_analyzed TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Table for tracking suggestion interactions
CREATE TABLE IF NOT EXISTS suggestion_interactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    suggestion_id UUID NOT NULL REFERENCES ai_suggestions(id) ON DELETE CASCADE,
    interaction_type TEXT CHECK (interaction_type IN ('viewed', 'applied', 'dismissed', 'feedback')) NOT NULL,
    feedback_rating INTEGER CHECK (feedback_rating BETWEEN 1 AND 5),
    feedback_text TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Table for suggestion generation logs
CREATE TABLE IF NOT EXISTS suggestion_generation_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    generation_type TEXT NOT NULL, -- 'topic', 'weakness', etc.
    input_data JSONB NOT NULL,
    output_count INTEGER NOT NULL,
    generation_time_ms INTEGER NOT NULL,
    success BOOLEAN NOT NULL DEFAULT true,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for better performance
CREATE INDEX IF NOT EXISTS idx_ai_suggestions_user_id ON ai_suggestions(user_id);
CREATE INDEX IF NOT EXISTS idx_ai_suggestions_type ON ai_suggestions(suggestion_type);
CREATE INDEX IF NOT EXISTS idx_ai_suggestions_priority ON ai_suggestions(priority);
CREATE INDEX IF NOT EXISTS idx_ai_suggestions_active ON ai_suggestions(is_active, expires_at);
CREATE INDEX IF NOT EXISTS idx_ai_suggestions_applied ON ai_suggestions(is_applied);
CREATE INDEX IF NOT EXISTS idx_ai_suggestions_created_at ON ai_suggestions(created_at DESC);

CREATE INDEX IF NOT EXISTS idx_student_profiles_user_id ON student_profiles(user_id);
CREATE INDEX IF NOT EXISTS idx_student_profiles_analyzed ON student_profiles(last_analyzed);

CREATE INDEX IF NOT EXISTS idx_suggestion_interactions_user_id ON suggestion_interactions(user_id);
CREATE INDEX IF NOT EXISTS idx_suggestion_interactions_suggestion_id ON suggestion_interactions(suggestion_id);
CREATE INDEX IF NOT EXISTS idx_suggestion_interactions_type ON suggestion_interactions(interaction_type);

CREATE INDEX IF NOT EXISTS idx_suggestion_generation_user_id ON suggestion_generation_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_suggestion_generation_type ON suggestion_generation_logs(generation_type);
CREATE INDEX IF NOT EXISTS idx_suggestion_generation_success ON suggestion_generation_logs(success);
CREATE INDEX IF NOT EXISTS idx_suggestion_generation_created_at ON suggestion_generation_logs(created_at DESC);

-- Enable Row Level Security
ALTER TABLE ai_suggestions ENABLE ROW LEVEL SECURITY;
ALTER TABLE student_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE suggestion_interactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE suggestion_generation_logs ENABLE ROW LEVEL SECURITY;

-- RLS Policies
-- Users can only see their own suggestions
CREATE POLICY "Users can view their own suggestions" ON ai_suggestions
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own suggestions" ON ai_suggestions
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own suggestions" ON ai_suggestions
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own suggestions" ON ai_suggestions
    FOR DELETE USING (auth.uid() = user_id);

-- Users can only see their own student profile
CREATE POLICY "Users can view their own student profile" ON student_profiles
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own student profile" ON student_profiles
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own student profile" ON student_profiles
    FOR UPDATE USING (auth.uid() = user_id);

-- Users can only see their own suggestion interactions
CREATE POLICY "Users can view their own suggestion interactions" ON suggestion_interactions
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own suggestion interactions" ON suggestion_interactions
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can only see their own generation logs
CREATE POLICY "Users can view their own generation logs" ON suggestion_generation_logs
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own generation logs" ON suggestion_generation_logs
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Admin can see all data
CREATE POLICY "Admins can view all suggestions" ON ai_suggestions
    FOR ALL USING (auth.role() = 'authenticated'); -- Simplified for demo

-- Function to update the updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers for updated_at
CREATE TRIGGER update_ai_suggestions_updated_at BEFORE UPDATE ON ai_suggestions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_student_profiles_updated_at BEFORE UPDATE ON student_profiles
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to clean up expired suggestions
CREATE OR REPLACE FUNCTION cleanup_expired_suggestions()
RETURNS void AS $$
BEGIN
    UPDATE ai_suggestions 
    SET is_active = false 
    WHERE expires_at < NOW() AND is_active = true;
END;
$$ LANGUAGE plpgsql;

-- Function to get active suggestions for a user
CREATE OR REPLACE FUNCTION get_active_suggestions(user_uuid UUID)
RETURNS TABLE (
    id UUID,
    suggestion_type TEXT,
    title TEXT,
    description TEXT,
    priority TEXT,
    estimated_impact INTEGER,
    reasoning TEXT,
    actionable_steps TEXT[],
    related_topics TEXT[],
    confidence_score DECIMAL,
    metadata JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.id,
        s.suggestion_type,
        s.title,
        s.description,
        s.priority,
        s.estimated_impact,
        s.reasoning,
        s.actionable_steps,
        s.related_topics,
        s.confidence_score,
        s.metadata
    FROM ai_suggestions s
    WHERE s.user_id = user_uuid 
    AND s.is_active = true 
    AND s.expires_at > NOW()
    ORDER BY 
        CASE s.priority 
            WHEN 'high' THEN 3 
            WHEN 'medium' THEN 2 
            WHEN 'low' THEN 1 
        END DESC,
        s.estimated_impact DESC,
        s.confidence_score DESC;
END;
$$ LANGUAGE plpgsql;
